# Current .pyi stub file describe all functionality supported by DIAL XL Types.

# DIAL XL Base Types

class MetaTable(type):
    def __init__(cls, *, ui_name: str | None = None, ui_note: str | None = None): ...
    @property
    def ui_name(cls) -> str: ...
    @ui_name.setter
    def ui_name(cls, value: str): ...
    @property
    def ui_note(cls) -> str | None: ...
    @ui_note.setter
    def ui_note(cls, value: str | None): ...

class Table(metaclass=MetaTable): ...

class Field[T: Type]:
    def __init__(
        self,
        *,
        ui_name: str | None = None,
        ui_note: str | None = None,
        value_type: type[T] | None = None,
    ): ...
    @property
    def ui_name(self) -> str: ...
    @ui_name.setter
    def ui_name(self, value: str) -> None: ...
    @property
    def ui_note(self) -> str | None: ...
    @ui_note.setter
    def ui_note(self, value: str | None) -> None: ...

class Dimension[T: Type](Field[T]): ...

# DIAL XL Type Hierarchy Types API

class Type: ...

class Primitive(Type):
    # Conversion Functions

    def as_string(self) -> Str: ...
    def as_number(self) -> Number: ...

    # Comparison Operators

    def __eq__(self, other: Primitive) -> Bool: ...
    def __ne__(self, other: Primitive) -> Bool: ...
    def __lt__(self, other: Primitive) -> Bool: ...
    def __le__(self, other: Primitive) -> Bool: ...
    def __ge__(self, other: Primitive) -> Bool: ...
    def __gt__(self, other: Primitive) -> Bool: ...

    # Logic Operators

    def __and__(self, other: Primitive) -> Bool: ...
    def __or__(self, other: Primitive) -> Bool: ...
    def __invert__(self) -> Bool: ...

class Number(Primitive):
    # Arithmetic Operators

    def __pos__(self) -> Number: ...
    def __neg__(self) -> Number: ...
    def __add__(self, other: Number) -> Number: ...
    def __sub__(self, other: Number) -> Number: ...
    def __mul__(self, other: Number) -> Number: ...
    def __truediv__(self, other: Number) -> Number: ...
    def __mod__(self, other: Number) -> Number: ...
    def __pow__(self, power: Number) -> Number: ...

    # Math Functions

    def abs(self) -> Number: ...
    def sqrt(self) -> Number: ...
    def round(self) -> Number: ...
    def floor(self) -> Number: ...
    def ceil(self) -> Number: ...
    def exp(self) -> Number: ...
    def log(self, base: Number) -> Number: ...
    def ln(self) -> Number: ...
    def log10(self) -> Number: ...
    def sin(self) -> Number: ...
    def cos(self) -> Number: ...
    def tan(self) -> Number: ...
    def asin(self) -> Number: ...
    def acos(self) -> Number: ...
    def atan(self) -> Number: ...

class Str(Primitive):
    @property
    def len(self) -> Number: ...

    # String Manipulation

    def lower(self) -> Str: ...
    def upper(self) -> Str: ...
    def trim(self) -> Str: ...
    def strip(self, substring: Str) -> Str: ...
    def strip_prefix(self, substring: Str) -> Str: ...
    def strip_postfix(self, substring: Str) -> Str: ...
    def replace(self, old: Str, new: Str) -> Str: ...
    def split(self, delimiter: Str) -> Array[Str]: ...

    # Substring Check

    def __contains__(self, item: Str) -> Bool: ...

    # String Arithmetic

    def __add__(self, other: Str) -> Str: ...

    # String Indexing and Slicing

    @overload
    def __getitem__(self, item: Number) -> Str: ...
    @overload
    def __getitem__(self, slicing: slice) -> Str: ...

class Bool(Primitive): ...

class Date(Primitive):
    # Date Construction

    @staticmethod
    def construct(year: Number, month: Number, day: Number) -> Date: ...

    # Date Properties

    @property
    def day(self) -> Number: ...
    @property
    def month(self) -> Number: ...
    @property
    def year(self) -> Number: ...

    # Date Arithmetic

    def __add__(self, days: Number) -> Date: ...
    def __sub__(self, days: Number) -> Date: ...

class RowRef[T: Table](Type):
    # Field Value Access

    def __getattr__(self, field_name: str) -> Type: ...

class Array[E: Type](Type):
    @property
    def len(self) -> Number: ...
    @property
    def field_names[T: Table](self: Array[RowRef[T]]) -> Array[Str]: ...

    # Array Construction

    @staticmethod
    def from_range(first_number: Number, last_number: Number) -> Array[Number]: ...
    @staticmethod
    def from_date_range(
        first_date: Date, last_date: Date, day_step: Number
    ) -> Array[Date]: ...
    @staticmethod
    def from_table[T: Table](table: type[T]) -> Array[RowRef[T]]: ...
    @staticmethod
    def from_field[T: Type](field: Field[T] | Dimension[T]) -> Array[T]: ...

    # Array Indexing and Slicing

    @overload
    def __getitem__(self: Array[E], index: Number) -> E: ...
    @overload
    def __getitem__(self: Array[E], slicing: slice) -> Array[E]: ...
    def __getattr__(self: Array[RowRef], field_name: str) -> Array[Type]: ...
    def slice_field[F: Type](self: Array[RowRef], field: Field[F]) -> Array[F]: ...

    # Array Transformers

    def filter(self, filter_condition: Callable[[E], Primitive]) -> Array[E]: ...
    def sort_rows_by(self, *sort_orders: Callable[[E], Primitive]) -> Array[E]: ...
    def sort_primitives[P: Primitive](self: Array[P]) -> Array[P]: ...
    def unique_rows_by(self, *unique_by: Callable[[E], Primitive]) -> Array[E]: ...
    def unique_primitives[P: Primitive](self: Array[P]) -> Array[P]: ...

    # Pivot and Unpivot

    def pivot[
        T: Table, A: Type
    ](
        self: Array[RowRef[T]],
        field_names: Callable[[RowRef[T]], Primitive],
        bucket_aggregation: Callable[[Array[RowRef[T]]], A],
    ) -> Pivot[A]: ...
    def unpivot(
        self: Array[RowRef],
        name_field: Field,
        value_field: Field,
        ui_name_filter: Callable[[Str], Bool] | None = None,
    ) -> Array[RowRef]: ...

    # Array[Primitive] Aggregations

    def min[P: Primitive](self: Array[P]) -> P: ...
    def max[P: Primitive](self: Array[P]) -> P: ...
    def mode[P: Primitive](self: Array[P]) -> P: ...

    # Array[Primitive] Scalar Comparison Operators

    def __eq__(self: Array[Primitive], other: Primitive) -> Array[Bool]: ...
    def __ne__(self: Array[Primitive], other: Primitive) -> Array[Bool]: ...
    def __lt__(self: Array[Primitive], other: Primitive) -> Array[Bool]: ...
    def __le__(self: Array[Primitive], other: Primitive) -> Array[Bool]: ...
    def __ge__(self: Array[Primitive], other: Primitive) -> Array[Bool]: ...
    def __gt__(self: Array[Primitive], other: Primitive) -> Array[Bool]: ...

    # Array[Primitive] Scalar Logic Operators

    def __and__(self: Array[Primitive], other: Primitive) -> Array[Bool]: ...
    def __or__(self: Array[Primitive], other: Primitive) -> Array[Bool]: ...
    def __invert__(self: Array[Primitive]) -> Array[Bool]: ...

    # Array[Primitive] Item Check

    def __contains__(self: Array[Primitive], item: Primitive) -> Bool: ...

    # Array[Number] Aggregations

    def sum(self: Array[Number]) -> Number: ...
    def mean(self: Array[Number]) -> Number: ...
    def geo_mean(self: Array[Number]) -> Number: ...
    def std_sample(self: Array[Number]) -> Number: ...
    def std_population(self: Array[Number]) -> Number: ...

    # Array[Number] Scalar Arithmetic

    def __pos__(self: Array[Number]) -> Array[Number]: ...
    def __neg__(self: Array[Number]) -> Array[Number]: ...
    def __add__(self: Array[Number], other: Number) -> Array[Number]: ...
    def __sub__(self: Array[Number], other: Number) -> Array[Number]: ...
    def __mul__(self: Array[Number], other: Number) -> Array[Number]: ...
    def __truediv__(self: Array[Number], other: Number) -> Array[Number]: ...
    def __mod__(self: Array[Number], other: Number) -> Array[Number]: ...
    def __pow__(self: Array[Number], power: Number) -> Array[Number]: ...

    # All per-element functions of underlying type may be called directly on Array[E] instance.
    # For example, array.as_string() or array.round() will apply corresponding function element-wise.

class Pivot[E: Type](Type):
    def __getitem__(self, field_literal: Str) -> E: ...
