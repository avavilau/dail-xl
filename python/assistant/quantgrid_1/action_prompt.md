# DIAL XL
Here is the description of a new programming language called DIAL XL. DIAL XL is used to manipulate tabular data.  
`Table` is a set of its `columns`. All tables' columns have the same number of `values`.  
`Table` might also be seen as `array` of its `rows`. Each `row` contains `value` for all the Table `columns`.  
Table is referenced by its name. E.g. `Table1` - this statement returns array of rows of the table `Table1`.  
Columns of the table can be referenced as `Table1[a]` - this statement returns array of values of column `a` of table `Table1`.  
Possible value types are: `text`, `number`, `row`, `boolean`, `date`,  also known as simple types.  
Another possible value type is an `array` which contains values of the one simple type.

Any `value` can be of simple type, `array`, `N/A` or empty.
## Create table
Here are examples of table creation:
### Create table with RANGE
```
table NewTable
  dim [id] = RANGE(10)
  [a] = 1
  [b] = "1"
  [c] = [a] + [id]
  [d]
  [e] = NA
```
Explanation:
This example defines table `NewTable` of six columns: `id`, `a`, `b`, `c`, `d` and `e`.  
The table is defined by collection of its column definitions. Each column can be defined by a formula that is evaluated row-by-row and produces column values.  
`dim [id] = RANGE(5)` - this formula declares column `id`:
- `RANGE(5)` returns array of numbers from 1 to 5. 
- `dim` is a keyword that says that the assigned values must be spread across the rows. It means that `dim` formula defines number of rows in the table. `NewTable` has 5 rows. 
- There must be only one `dim` per table and dim formula must not depend on other columns of the table.
- Without `dim` keyword a table would have only one row.

`[a] = 1` defines a column named `a` assigns 1 to every row of the `a`.  
`[b] = [id] + 1` defines column `b` which has values from `[id]` increased by 1. Formula `[id] + 1` is evaluated for every row and statement `[id]` refers to value of `[id]` for current row.  
`[c] = [a] + [b]` defines [c] as to row-by-row sum of [a] and [b].  
`[d]` - column is defined, but no value is assigned, column values will be empty.  
`[e] = NA`  all column values are assigned to N/A values.

### Create table from INPUT
```
table TableFromInput
  dim [source] = INPUT("data_path/table.csv")
  [a] = [source][col1]
  [b] = 1
  [c] = "1"
```
Explanation:
`table TableFromInput` - table definition and naming.  
`dim [source] = INPUT("data_path/table.csv")` declares that column [source] of table `TableFromInput` consists of all rows of table stored by data_path. That will make `TableFromInput` to has the same number of rows as table in "data_path/table.csv".  
`[a] = [source][col1]` references column `col1` from the row in [source]. Column [a] will store values from column `col1`.

### Create table from another table
```
table DerivedTable
  dim [source] = NewTable
  [a] = [source][c]
  [b] = [source][d]
  [c] = "some constant text"
  [d] = "another constant text"
  [e] = [c] & " " & [d]
```
Explanation:  
`table DerivedTable` - table definition and naming.  
`dim [source] = NewTable` declares that column [source] of table `DerivedTable` stores all rows of table `NewTable`. `DerivedTable` will have the same number of rows as `NewTable`.  
`[a] = [source][c]` for every row of column [a] we take a row of `NewTable` stored in [source] and extract column [c].  
`[c] = "some constant text"` sets every row of column [c] to text "some constant text".  
`[d] = "another constant text"` sets every row of column [d] to text "another constant text".  
`[e] = [c] & " " & [d]` sets every row of column [e] equal to row-by-row concatenation of [c], whitespace and [d], making it being equal to "some constant text another constant text". 

### Manual table
You can explicitly populate data into table like this:
```
!manual()
table TManual
  [color]
  [size]
  [color_label] = "Color: " & [color]
override
  [color],[size]
  "red", 10
  "green", 5
  "blue", 15
```
Explanation:  
`!manual()` means that this table rows are generated by manually entered data. The override section must list all manually entered columns. The override section can't contain any DIAL XL formulas. The override section must only contain values.  
Use double quotes for text values if it's not table column name.

## Simple functions
DIAL XL allows to perform simple operations on text, numbers and dates. When such functions or operators are used on rows, it means that they're applied row-by-row.
### Numeric data
Supported functions are `ROUND, ABS, SQRT, ROUND, FLOOR, CEIL, EXP, LOG, LN, LOG10, SIN, COS, TAN, ASIN, ACOS, ATAN`. These functions take number as an argument , e.g. `ROUND(number)`.  
Supported operators are `+, - (unary and binary), / , *, ^, AND/OR, NOT, MOD`.  
Supported comparison operators are `<, >, <=, >=, =, <>`. They return boolean values TRUE/FALSE.

Example:
```
## table to show example of numeric manipulations
## this is a note that will be shown as part of the table
table NumericExampleTable
  dim [id] = RANGE(10) ## table id
  [a] = 1 / [id]
  [b] = 1 - ROUND([a])
  [c] = [a] >= [b] # will contain TRUE and FALSE values
  [d] = ([a] + [b]) * ([a] ^ 2)
  [e] = VALUE("10")
```
Explanation:
`dim [id] = RANGE(10)` fills dim column [id] with numbers from 1 to 10.  
`## table id` is a note that will be shown as part of the column. It can contain important information about the column.  
`[a] = 1 / [id]` divides 1 by id value row-by-row.  
`[b] = 1 - ROUND([a])` subtracts rounded value in current row of column [a] from 1. `ROUND(number)` rounds real number to natural number. Rounding to certain precision is not supported.  
`[c] = [a] >= [b]` will return binary TRUE and FALSE values depending on condition.  
`# will contain TRUE and FALSE values` is a comment. Not executed and not visible on the UI.  
`[d] = ([a] + [b]) * ([a] ^ 2)` - here operation priority is: ^, *, +. You can control priorities with parenthesis.  
`[e] = VALUE("10")` transforms "10" as text into 10 as a number.
### Text data
Supported functions are `LEN, LOWER, UPPER, TRIM, STRIP, STRIP_START, STRIP_END, CONCATENATE, CONCAT, &, SUBSTITUTE, LEFT, RIGHT, MID, CONTAINS`. All these functions can be used in two ways: `LEN(text_value)` or `text_value.LEN()`.  
Functions can be applied to the whole column like this: `LEN(TableName[column_name])`, returning array of results.

Example:
```
table ItemPrices
  dim [source] = INPUT("path/prices.csv")
  [id] = [source][item_id]
  [region_code] = [source][region_code]
  [item_name] = "Item: " & [source][item_name]
  [price_with_currency] = [source][price_with_currency]
  [item_name_len] = LEN([item_name])
  [item_region] = LEFT([region_code], 2)
  [item_currency] = RIGHT([price_with_currency], 1)
  [price_with_usd] = SUBSTITUTE([price_with_currency], "$", "USD")
  [text_id] = TEXT([id])
  [contains_gluten] = CONTAINS([item_name], "gluten")
```
Explanation:  
`dim [source] = INPUT("path/prices.csv")` loads table from file.  
`[item_name] = "Item: " & [source][item_name]` concatenates text with a text column. Alternatively, `CONCAT("Item: ", [source][item_name])` or `CONCATENATE("Item: ", [source][item_name])` can be used for text concatenation.  
`[item_name_len] = LEN([item_name])` - the column will store lengths of values in [item_name] row-by-row.  
`[item_region] = LEFT([region_code], 2)`  - the column will store first 2 characters of values in [region_code] row-by-row.  
`[item_currency] = RIGHT([price_with_currency], 1)`  - the column will store last 1 character of values in [price_with_currency] row-by-row.  
`[price_with_usd] = SUBSTITUTE([price_with_currency], "$", "USD")` - all occurrences of "$" will be replaced by "USD" for this column.  
`[text_id] = TEXT([id])` transforms numeric data into text type.  
`[contains_gluten] = CONTAINS([item_name], "gluten")` - the column value will store TRUE if the text value of the column [item_name] in current row contains word "gluten" or FALSE otherwise.
### Date data
Supported functions are `DATE(year, month, day), YEAR(date), MONTH(date), DAY(date)`.

Example:
```
table DateExampleTable
  dim [id] = RANGE(10)
  [full_date] = DATE(2025, [id], [id] + 5)
  [year] = YEAR([full_date])
  [month] = MONTH([full_date])
  [day] = DAY([full_date])
```
`[full_date] = DATE(2025, [id], [id] + 5)` creates column with dates. Year 2025, month is equal to [id] value, day is equal to [id] + 5.  
`[year] = YEAR([full_date])` extracts year from date as a number.  
`[month] = MONTH([full_date])` extracts month from date as a number.  
`[day] = DAY([full_date])` extracts day from date as a number.
## Aggregations
Supported aggregations for arrays are `AVERAGE, SUM, COUNT, MAX, MIN, FIRST, LAST, MODE (most frequent value), STDEVP, STDEVS`. `COUNT, FIRST, LAST, MODE` can be applied to tables, text and numeric arrays, others can be used only for numeric arrays. 

All these aggregations can be used in two ways: `COUNT(table_or_array)` or `table_or_array.COUNT()`.

Aggregation functions must be applied to arrays like this: `MAX(Table[column])`.

Example:
```
table TBase
  dim [id] = RANGE(20)
  [a] = ROW() + 10
  [b] = [a] ^ 2

table TAggregations
  [tbase_row_count] = COUNT(TBase)
  [a_count] = COUNT(TBase[a])
  [a_sum] = SUM(TBase[a])
  [b_first] = FIRST(TBase[b])
  [b_avg] = AVERAGE(TBase[b])
  [b_max] = MAX(TBase[b])
  [b_2nd] = TBase[b].INDEX(2)
```
Explanation:  
Table `TAggregations` doesn't have `dim` column which means it has only one row.
`[tbase_row_count] = COUNT(TBase)` equals number of rows in TBase.  
`[a_count] = COUNT(TBase[a])` alternative version of count with the same result.  
`[a_sum] = SUM(TBase[a])` equals total sum of all elements in TBase[a].  
`[b_first] = FIRST(TBase[b])` equals to first value of column TBase[b].  
`[b_avg] = AVERAGE(TBase[b])` equals to the average of all values in column TBase[b].  
`[b_max] = MAX(TBase[b])` equals to the max of all values in column TBase[b].  
`[b_2nd] = TBase[b].INDEX(2)` equals to 2nd element in column TBase[b].

You can use `FIRST` as a convenient way to get a value from array of length 1. Continuing previous example:
```
table TFirstExample
  [tbase_row_count_list] = TAggregations[tbase_row_count]
  [tbase_row_count_single] = FIRST(TAggregations[tbase_row_count])
```
Explanation:  
Table `TFirstExample` also has only 1 row, because there is no `dim`.  
`[tbase_row_count_list] = TAggregations[tbase_row_count]` - the only value in column [tbase_row_count_list] would be `[20]`, an array with one value.
`[tbase_row_count_single] = FIRST(TAggregations[tbase_row_count])` - the only value in column [tbase_row_count_single] would be a single number `20`.

## Array functions
Supported functions for arrays are `FILTER, SORTBY, UNIQUE, IN`.

Example:
```
table T0
  dim [id] = RANGE(10)
  [a] = ROW() + 10
  [b] = [a] ^ 0.5
  [c] = "text " & [b]
  
table T1
  dim [id] = RANGE(5)
  [col1] = "some text"
  
table T2
  dim [source] = INPUT("path_to_data/table_file.csv")
  [uuid] = [source][uuid]
  [reference_col] = [source][reference_col]
```
### Sorting
`SORTBY(table_or_array, comma_separated_keys)` function can sort the table by any number of keys from that table and returns rows. It can be applied to array as well: `SORTBY(column_name, comma_separated_keys)`, then it returns sorted array. Alternative way is `table_or_array.SORTBY(comma_separated_keys)`.

Example:
```
table TSortedColumn
  dim [a] = SORTBY(T0, T0[a])[a]
```
Explanation:  
`TSortedColumn` has one column [a] that contains all values of `T0[a]` sorted in ascending order. Table `TSortedColumn` has the same length as `T0`.

Example:
```
table TSortedTable
  dim [source] = SORTBY(T0, T0[a], -T0[b])
  [a] = [source][a]
  [b] = [source][b]
```
Explanation:  
`TSortedTable` has column [source] that stores sorted rows of `T0` and has the same length. Rows of `T0` in [source] are sorted by [a] in ascending order and then by [b] in descending order.  
Columns [a] and [b] store values of columns from sorted version of `T0` that we have in [source].
### Unique
`UNIQUE(array)` function can return all unique values from array.
```
table TUnique
  dim [source] = UNIQUE(T0[b])
```
Explanation:  
Table `TUnique` has one column [s] that contains unique values of `T0[b]`.
### Conditions
Columns can be populated based on condition with `IF(condition, value_if_true, value_if_false)` and `IFNA(value, value_if_na)` functions.

Example:
```
table TConditions
  dim [condition_id] = RANGE(5)
  [a] = IF([condition_id] = [condition_id] ^2, 10, NA)
  [b] = IFNA([a], 5)
```
Explanation:  
`[a] = IF([condition_id] = [condition_id] ^2, 10, NA)` will populate [a] row with 10 if condition is satisfied and with N/A otherwise.  
`[b] = IFNA([a], 5)` will populate [b] with values from [a] and replace N/A with 5.
### Filtering
`FILTER(table_or_array, condition)` is a powerful function for filtering tables and arrays based on condition. It returns table or array. It can also be used like this `table_or_array.FILTER(condition)`.

Example:
```
table TSimpleFilter
  dim [source] = FILTER(T0, T0[b] <= 4)
  [a] = [source][a]
  [b] = [source][b]
```
Explanation:  
`dim [source] = FILTER(T0, T0[b] <= 4)` here we filter table `T0`. `T0[b]` is an array of values from column [b] of table `T0` that we check to be less than 4. 
`[a] = [source][a]` column [a] contains all values of column [a] from [source], where [source] stores filtered rows of `T0`.

Example:
```
table TFilterColumn
  dim [filtered_id] = FILTER(T0, T0[b] > 4)[id]
```
Explanation:  
`dim [filtered_id] = FILTER(T0, T0[b] > 4)[id]` - each value will contain values from column [id] of rows of table `T0` that match the condition. `dim` means that these values will define number of rows of `TFilterColumn`.

### Examples
In this section you can find examples for FILTER and other functions based on data about sold clothes.

Data for the examples:
```
!manual()
table TClothes
  [id]
  [price]
  [name]
override
  [id], [price],[name]
  1, 20, "t-shirt"
  2, 40, "shirt"
  3, 100, "skirt"
  4, 2000, "jacket"
  5, 500, "dress"
  
!manual()
table TSale
  [sale_price]
  [item_id]
  [item_name]
override
  [sale_price], [item_id], [item_name]
  10, 1, "t-shirt"
  250, 5, "dress"
  
table TPurchases
  dim [source] = INPUT("path_to_data/purchases.csv")
  [purchase_id] = [source][purchase_id]
  [clothes_id] = [source][clothes_id]
  [clothes_name] = [source][clothes_name]
  [purchase_date] = [source][purchase_date]
  [cost] = [source][cost]
```

#### Sale items purchases:
We can find all purchased items that are now on sale.
```
table PurchasedSaleItems
  dim [source] = TPurchases.FILTER(IN(TPurchases[clothes_id], TSale[item_id]))
  [clothes_id] = [source][clothes_id]
  [purchase_date] = [source][purchase_date]
```
Explanation:  
`dim [source] = TPurchases.FILTER(IN(TPurchases[clothes_id], TSale[item_id]))` here [source] will store filtered rows of `TPurchases` table that satisfy the condition. `IN(value, array)` function checks if value on current row of `TPurchases[clothes_id]` is among values in `TSale[item_id]`. This way rows for sale items are extracted.
#### Top 3 example:
Here we find top 3 cheapest items in manual table `TClothes`.
```
table Top3CheapPrices
  dim [source] = SORTBY(TClothes, TClothes[price]).FIRST(3)
  [price] = [source][price]
  [name] = [source][name]
```
Explanation:  
`dim [source] = SORTBY(TClothes, TClothes[price]).FIRST(3)` table `Top3CheapPrices` will have 3 rows, column [source] contains rows from `TClothes`.
#### Most frequent example:
Here we find top 3 most popular items from `TPurchases` table.
```
table TPurchasesFrequency
  dim [clothes_id] = UNIQUE(TPurchases[clothes_id])
  [purchases_count] = TPurchases.FILTER(TPurchases[clothes_id] = [clothes_id]).COUNT()
  
table MostFrequentTable
  [source] = SORTBY(TPurchasesFrequency, -TPurchasesFrequency[purchases_count]).FIRST()
  
table MostFrequentTableAlternative
  [most_frequent_clothes_id] = MODE(TPurchases[clothes_id])
```
Explanation:  
Helper table `TPurchasesFrequency` is created to gather clothes ids and number of times they were purchased.
`dim [clothes_id] = UNIQUE(TPurchases[clothes_id])` [clothes_id] column is based on unique values of `TPurchases[clothes_id])`.  
`[purchases_count] = TPurchases.FILTER(TPurchases[clothes_id] = [clothes_id]).COUNT()` here `TPurchases` is filtered based on condition and resulting number of rows is counted. Condition is `TPurchases[clothes_id] = [clothes_id]`, where `TPurchases[clothes_id]` is a value from the column of the table we're filtering. [clothes_id] is a value of column [clothes_id] from `TPurchasesFrequency` on the current row.  
Resulting table `MostFrequentTable` has one column with a one value that contains first row from sorted `TPurchasesFrequency`.  
Additionally, `MostFrequentTableAlternative` table shows simpler way of getting one most frequently purchased item.

Like in this example, `SORTBY` and `FILTER` should always be on separate lines.
#### Filtering by date
Here we find the number of jackets sold in the last two weeks of June:
```
table TLateJuneJackets
  [jackets_count] = TPurchases.FILTER(MONTH(TPurchases[purchase_date]) = 6 AND DAY(TPurchases[purchase_date]) >= 15 AND TPurchases[clothes_id] = 4).COUNT()
```
Explanation:
`[jackets_count] = TPurchases.FILTER(MONTH(TPurchases[purchase_date]) = 6 AND DAY(TPurchases[purchase_date]) >= 15 AND TPurchases[clothes_id] = 4).COUNT()` filters purchases in `TPurchases` by month and day. Additionally, it checks for the purchased clothes id to be the one for jacket. For the result of this filter we calculate the number of rows.

## Decorators
Existing decorators:  
`!layout(2, 2, "title", "headers")` for placing table in a specific location on the sheet.  
`!size(3)` for setting column width (default = 1).  
`!manual()` for manual table declaration.
