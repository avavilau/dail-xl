package com.epam.deltix.quantgrid.engine.node.plan.local;

import com.epam.deltix.quantgrid.engine.Util;
import com.epam.deltix.quantgrid.engine.meta.Meta;
import com.epam.deltix.quantgrid.engine.meta.Schema;
import com.epam.deltix.quantgrid.engine.node.expression.Get;
import com.epam.deltix.quantgrid.engine.node.plan.Plan;
import com.epam.deltix.quantgrid.engine.node.plan.Plan2;
import com.epam.deltix.quantgrid.engine.value.DoubleColumn;
import com.epam.deltix.quantgrid.engine.value.Table;
import com.epam.deltix.quantgrid.engine.value.local.LocalTable;
import it.unimi.dsi.fastutil.longs.LongArrayList;

/**
 * Class is used to fill in gaps in the provided nested Plan by using carry's (left) row number and other columns.
 *
 * <p>Nested plan is initially generated by joining (inner) carry (left) with some other Plan. In a result of a
 * join (inner) some records of the carry (left) Plan might match nothing of the right table and won't
 * be present in the nested Plan.
 *
 * <p>When explode happens for this nested Plan, we want to have a flat table as if original join was left,
 * so that all records of the left table are present with nulls on the right.
 * This Plan is doing exactly this: adding such missing rows to the nested, using carry as a source of
 * current row number and other columns (if used downstream).
 */
public class GapFillerJoinLocal extends Plan2<Table, Table, Table> {

    public GapFillerJoinLocal(Plan carry, Get leftRef, Plan nested, Get nestedLeftRef) {
        super(sourceOf(carry, leftRef), sourceOf(nested, nestedLeftRef));
    }

    @Override
    protected Plan layout() {
        return this;
    }

    @Override
    protected Meta meta() {
        return new Meta(Schema.inputs(this, 0, 1));
    }

    @Override
    protected Table execute(Table carry, Table nested) {
        // for local implementation we can simply use carrySize in a loop, instead of a RowNumber column
        int carrySize = Util.toIntSize(carry);

        DoubleColumn nestedLeftRef = expression(1, 0).evaluate();
        ExpandedReferences refs = fillGaps(carrySize, nestedLeftRef);

        return LocalTable.compositeOf(
                LocalTable.indirectOf(carry, refs.carry()),
                LocalTable.indirectOf(nested, refs.nested())
        );
    }

    private static ExpandedReferences fillGaps(long currySize, DoubleColumn nestedLeftRefs) {
        int nestedSize = Util.toIntSize(nestedLeftRefs);

        LongArrayList carryRefs = new LongArrayList(nestedSize);
        LongArrayList nestedRefs = new LongArrayList(nestedSize);

        long index = 0; // index of the 'nested'
        for (long rn = 0; rn < currySize; rn++) {
            if (index >= nestedSize || nestedLeftRefs.get(index) > rn) {
                carryRefs.add(rn);
                nestedRefs.add(Util.NA_REF);
            } else {
                while (index < nestedSize && nestedLeftRefs.get(index) == rn) {
                    carryRefs.add(rn);
                    nestedRefs.add(index++);
                }
            }
        }

        return new ExpandedReferences(carryRefs, nestedRefs);
    }

    private record ExpandedReferences(LongArrayList carry, LongArrayList nested) {
    }
}
